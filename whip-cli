#!/usr/bin/env python

import logging
import os
import shutil
from socket import inet_aton
import sys
import tempfile
import time

import aaargh
import plyvel
import simplejson as json

from whip.db import Database
from whip.util import buffer_iter


logger = logging.getLogger(__name__)

BUFFERED_RECORDS_PER_IMPORTER = 10000
MAX_BUFFERED_RECORDS = 1000 * 1000


def json_pp(s):
    return json.dumps(json.loads(s), indent=2, sort_keys=True)


def lookup_and_print(db, ip, dt):
    value = db.lookup(inet_aton(ip), dt)
    if value is None:
        print("No hit found")
    else:
        print(json_pp(value))


app = aaargh.App(description="Fast IP geo lookup")
app.arg('--database-dir', '--db', default='db')


@app.cmd(name='load', help="Load data")
@app.cmd_arg('--data-files', nargs='+', required=True)
@app.cmd_arg('--no-ref-lookups', dest='ref_lookups', action='store_false')
def load_data(database_dir, data_files, ref_lookups):

    logger.info(
        "Importing %d data directories: %r",
        len(data_files), data_files)

    if not ref_lookups:
        logger.warning(
            "Reference database lookups disabled; "
            "resulting database will be incomplete!")

    tmp_dir = tempfile.mkdtemp(prefix='whip-', suffix='.ldb')
    logger.info("Creating temporary database in %r", tmp_dir)
    tmp_db = plyvel.DB(
        tmp_dir,
        create_if_missing=True,
        write_buffer_size=128 * 1024**2,  # 128 MB
        lru_cache_size=1024**3,  # 1 GB
        max_open_files=128,
        bloom_filter_bits=10,
    )

    try:
        from whip.importers.quova import QuovaImporter

        prefix_generator = (chr(i) for i in xrange(256))
        importers = [
            QuovaImporter(
                data_file=data_file,
                tmp_db=tmp_db.prefixed_db(next(prefix_generator)),
                ref_lookups=ref_lookups)
            for data_file in data_files
        ]

        iters = [importer.iter_records() for importer in importers]

        # Wrap into buffering generators to (hopefully) exploit the LRU
        # cache in the temporary database.
        bufsize = min(
            BUFFERED_RECORDS_PER_IMPORTER,
            MAX_BUFFERED_RECORDS / len(iters))
        logger.info("Buffering %d records in memory per importer", bufsize)
        iters = [buffer_iter(it, bufsize) for it in iters]

        db = Database(database_dir, create_if_missing=True)
        db.load(*iters)

    finally:
        tmp_db.close()
        shutil.rmtree(tmp_dir)


@app.cmd(name="lookup")
@app.cmd_arg('ips', help="The IP address(es) to lookup", nargs='+')
@app.cmd_arg('--datetime', '--dt', dest='dt')
def lookup(ips, database_dir, dt):
    db = Database(database_dir)
    for ip in ips:
        lookup_and_print(db, ip, dt)


@app.cmd(name="shell")
@app.cmd_arg('--datetime', '--dt', dest='dt')
def shell(database_dir, dt):
    db = Database(database_dir)
    while True:
        ip = raw_input('IP: ')
        lookup_and_print(db, ip, dt)


@app.cmd(name='perftest', help="Run performance test")
@app.cmd_arg('--iterations', '-n', default=100 * 1000, type=int,
             help="The number of iterations")
@app.cmd_arg('--datetime', '--dt', dest='dt')
def perftest(database_dir, iterations, dt):
    logger.info("Running %d iterations", iterations)
    db = Database(database_dir)
    size = 4

    # Use a sliding window over random data to obtain 4 bytes at a time
    rand_bytes = os.urandom(iterations + size - 1)

    lookup = db.lookup
    start_time = time.time()
    for n in xrange(iterations):
        lookup(rand_bytes[n:n + size], dt)

    elapsed = time.time() - start_time
    out = "{:d} lookups in {:.2f}s ({:.2f} req/s)".format(
        iterations, elapsed, iterations / elapsed)
    print(out)


@app.cmd
@app.cmd_arg('--host', default='0')
@app.cmd_arg('--port', type=int, default=5555)
def serve(host, port, database_dir):
    from whip.web import app
    app.config['DATABASE_DIR'] = database_dir
    app.run(host=host, port=port)


def main():
    logging.basicConfig(
        format='%(asctime)s (%(name)s) %(levelname)s: %(message)s',
        level=logging.INFO,
    )
    return app.run()


if __name__ == '__main__':
    sys.exit(main())
